<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python+pyqt5编写爬虫界面（界面与处理逻辑分离）]]></title>
    <url>%2F2020%2F01%2F04%2Fpython%E7%BC%96%E5%86%99%E7%88%AC%E8%99%AB%EF%BC%8Cpyqt5%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[这段时间比较空闲，对爬虫比较感兴趣，所以用pyqt5作为爬虫数据的展示界面，以下为我学习过后的代码整理 界面设计工具 Qt Designer该工具下载，请自行百度，使用方法：拖拽控件设计界面，修改控件名称等，不再赘述 安装python 运行依赖12pip install pyqt5 #qt界面必须引入pip install pyinstaller #应用打包生成exe ui文件转换py文件1pyuic5 -o &lt;生成py文件名&gt; &lt;原ui文件名&gt; 几个py文件说明 main.py # 主启动程序类 view.py # ui生成的界面编写类 thread.py # 线程类 code.py #爬虫逻辑类 main.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from PyQt5.QtWidgets import QMainWindow, QMessageBox, QTableWidgetItem, QApplicationfrom PyQt5.QtCore import Qt, pyqtSlotfrom view import Ui_MainWindowfrom thread import *class MainWindow(QMainWindow, Ui_MainWindow): def __init__(self, parent=None): super(MainWindow, self).__init__(parent) self.setupUi(self) self._page = 1 self._key = "" self.list_ = [] self.search_btn.clicked.connect(self.search_click) self.search_input.returnPressed.connect(lambda: self.search_click) @pyqtSlot() def search_click(self): _key = self.search_input.text() if _key == '': return QMessageBox.warning(self, '提示', '请输入关键词') self.to_search() def to_search(self, page_num=1): key_word = self.search_input.text() self.list_.clear() self.table_widget.clear() self.table_widget.setRowCount(0) self.table_widget.setColumnCount(0) self.search_thread = FirstThread(self, key_word, page_num) self.search_thread.search_signal.connect(self.return_list_first) # 连接信号 self.search_thread.start() # 开始线程 def return_list_first(self, _list): if len(_list) == 0: return QMessageBox.warning(self, '提示', '搜索结果为空') # 必须加self self.thread_1 = UrlThread(self, _list) self.thread_1.url_signal.connect(self.return_list_second) # 连接信号 self.thread_1.start() # 开始线程 def return_list_second(self, _item): if len(_item) &lt;= 0: return QMessageBox.warning(self, '提示', '搜索结果为空') self.list_.append(_item) list_col = ['title', 'time', 'url'] _col = len(list_col) _table = self.table_widget row_count = _table.rowCount() _table.setRowCount(row_count) # 设置行数 _table.setColumnCount(_col) # 设置列数 _table.setHorizontalHeaderLabels(['标题', '发布时间', '操作']) _table.insertRow(row_count) _table.setItem(row_count, 0, QTableWidgetItem(_item['title'])) _table.setItem(row_count, 1, QTableWidgetItem(_item['time'])) url_btn = QTableWidgetItem("下载") url_btn.setTextAlignment(Qt.AlignCenter) _table.setItem(row_count, 2, url_btn) _table.setColumnWidth(0, 400) _table.setColumnWidth(1, 100) self.table_widget = _tableif __name__ == "__main__": import sys app = QApplication(sys.argv) ui = MainWindow() ui.show() sys.exit(app.exec_()) thread.py12345678910111213141516171819202122232425262728293031323334353637from PyQt5.QtCore import QThread, pyqtSignalfrom code_sd import *import requests# 爬取分页信息class FirstThread(QThread): search_signal = pyqtSignal(list) # 括号里填写信号传递的参数 def __init__(self, _obj, _key, _page): self._key = _key self._page = _page super().__init__() def __del__(self): self.wait() def run(self): # 进行任务操作 text = search_url_list(_key=self._key, _page=self._page) self.search_signal.emit(text) # 爬取详情页 class UrlThread(QThread): url_signal = pyqtSignal(dict) # 括号里填写信号传递的参数 def __init__(self, _obj, _url): self._url = _url super().__init__() def __del__(self): self.wait() def run(self): # 进行任务操作 for i in self._url: text = search_detail(str(i)) self.url_signal.emit(text) code.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsfrom lxml import etreeimport osfrom urllib import parseheaders = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36'&#125;search_url = "http://www.mtx.cn/viewcontent/bglist_&#123;0&#125;.htm?orderby=26"index_path = "http://www.mtx.cn"# 3.获取研究报告详情def get_detail(s, url): html = s.get(index_path+url, headers=headers) bs = etree.HTML(html.text) title = bs.xpath('//div[@class="yl-AllConL"]//div[@class="yl-matterTit"]/text()')[0] time = bs.xpath('//div[@class="yl-AllConL"]//div[@class="yl-matterBq"]/span/text()')[3].split( )[0] title = title.replace("/", "-") _url = "" # print("正在获取研究报告：" + title + "时间：" + str(time) + "链接：" + _url) report = dict(title=title, time=time, url=_url) return report # down_file(s, _url, save_path, title)# 创建路径def create_file(path): # 创建路径路径 if not os.path.exists(path): # 创建路径 os.makedirs(path)# 1获取分页详情url[]def search_url_list(_key, _page): url = "http://www.mtx.cn/pcm/search_"+str(_page)+".jspx?channelid=63&amp;query="+parse.quote(str(_key)) # print("正在解析页码："+url) s = requests.session() html = s.get(url, headers=headers) bs = etree.HTML(html.text) design = bs.xpath('//div[@class="w1200 yl-AllCon searchpage"]//div[@class="yl-AllConL"]//ul[@class="yl-ZxList demo0427"]//li/a/@href') return design# 2根据详情url获取信息def search_detail(_url): s = requests.session() _report = get_detail(s, _url) return _reportdef main(): # 创建会话 s = requests.Session()if __name__ == '__main__': main() view.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding: utf-8 -*-# Form implementation generated from reading ui file 'view.ui'## Created by: PyQt5 UI code generator 5.14.0## WARNING! All changes made in this file will be lost!from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_MainWindow(object): def setupUi(self, MainWindow): MainWindow.setObjectName("MainWindow") MainWindow.setFixedSize(MainWindow.width(), MainWindow.height()) MainWindow.resize(671, 463) MainWindow.setWindowIcon(QtGui.QIcon(':/search.ico')) self.centralwidget = QtWidgets.QWidget(MainWindow) self.centralwidget.setObjectName("centralwidget") self.horizontalLayoutWidget = QtWidgets.QWidget(self.centralwidget) self.horizontalLayoutWidget.setGeometry(QtCore.QRect(20, 0, 631, 51)) self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget") self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget) self.horizontalLayout.setContentsMargins(0, 0, 0, 0) self.horizontalLayout.setObjectName("horizontalLayout") self.search_input = QtWidgets.QLineEdit(self.horizontalLayoutWidget) self.search_input.setObjectName("search_input") self.horizontalLayout.addWidget(self.search_input) self.search_btn = QtWidgets.QPushButton(self.horizontalLayoutWidget) self.search_btn.setObjectName("search_btn") self.horizontalLayout.addWidget(self.search_btn) self.table_widget = QtWidgets.QTableWidget(self.centralwidget) self.table_widget.setGeometry(QtCore.QRect(20, 50, 631, 341)) self.table_widget.setObjectName("table_widget") self.table_widget.setColumnCount(0) self.table_widget.setRowCount(0) self.horizontalLayoutWidget_2 = QtWidgets.QWidget(self.centralwidget) self.horizontalLayoutWidget_2.setGeometry(QtCore.QRect(180, 390, 211, 41)) self.horizontalLayoutWidget_2.setObjectName("horizontalLayoutWidget_2") MainWindow.setCentralWidget(self.centralwidget) self.menubar = QtWidgets.QMenuBar(MainWindow) self.menubar.setGeometry(QtCore.QRect(0, 0, 671, 23)) self.menubar.setObjectName("menubar") MainWindow.setMenuBar(self.menubar) self.statusbar = QtWidgets.QStatusBar(MainWindow) self.statusbar.setObjectName("statusbar") MainWindow.setStatusBar(self.statusbar) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow")) self.search_btn.setText(_translate("MainWindow", "搜索")) 界面展示]]></content>
      <categories>
        <category>爬虫初级</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyqt5</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos Linux下搭建Asp.Net环境]]></title>
    <url>%2F2019%2F05%2F10%2FCentos-Linux%E4%B8%8B%E6%90%AD%E5%BB%BAAsp.Net%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[记录在linux部署Asp.Net运行环境，使用 Mono + Jexus 部署，Mono是linux运行asp.net必须的编译环境，Jexus是国人开发的反向代理服务器，功能类似Nginx,但是Jexus更加强大，支持Asp.Net运行。 Jexus官网地址：https://www.jexus.org/ 传统Mono+Jexus安装方法（较繁琐不推荐）Jexus通用版不带 .NET运行时，因此，使用者应该首先在客户机安装mono和libgdiplus。 在Ubuntu上安装Mono，可参见 在Ubuntu操作系统上安装mono的具体方法在CentOS上安装Mono，可参见 张善友先生写的CentOS Mono安装教程 安装jexus通用版的命令是：curl https://jexus.org/release/install|sudo sh 注：运行安装命令，需要操作者有root权限。 安装Jexus独立版（集成了Mono）1.安装命令 1$ curl https://jexus.org/release/x64/install.sh|sudo sh 2.安装成功后，自动生成安装目录：/usr/jexus/ 3.运行Jexus命令 12$ cd /usr/jexus/$ ./jws start 4.网页访问（默认配置文件/usr/jexus/siteconf/default,默认端口80，默认访问目录/var/www/default） 1$ http://localhost:80/info 看到以上页面说明安装成功 4.新建默认的项目路径 1$ mkdir /var/www/default 将项目文件复制到 /var/www/default目录下 5.自定义配置 1$ vi /usr/jexus/siteconf/default 核心配置 12port=80root=/ /var/www/default #默认访问目录，可自定义 6.常用命令 123$ ./jws start$ ./jws restart$ ./jws stop 安装成功后遇到的问题解答1.System.IO.IOException 详细错误代码： 12345678910111213System.IO.IOExceptionThe configured user limit (128) on the number of inotify instances has been reached.Description: HTTP 500.Error processing request.Details: Non-web exception. Exception origin (name of application or object): System.Exception stack trace: at System.IO.CoreFX.FileSystemWatcher.StartRaisingEvents () [0x0007b] in &lt;e35dfeba7ed248b1a1d7afe3381392f9&gt;:0 at System.IO.CoreFX.FileSystemWatcher.StartRaisingEventsIfNotDisposed () [0x00019] in &lt;e35dfeba7ed248b1a1d7afe3381392f9&gt;:0 at System.IO.CoreFX.FileSystemWatcher.set_EnableRaisingEvents (System.Boolean value) [0x0001d] in &lt;e35dfeba7ed248b1a1d7afe3381392f9&gt;:0 at (wrapper remoting-invoke-with-check) System.IO.CoreFX.FileSystemWatcher.set_EnableRaisingEvents(bool) at System.IO.CoreFXFileSystemWatcherProxy+&lt;&gt;c.&lt;StartDispatching&gt;b__9_0 (System.IO.CoreFX.FileSystemWatcher internal_fsw, System.IO.FileSystemWatcher fsw) [0x00048] in &lt;e35dfeba7ed248b1a1d7afe3381392f9&gt;:0 at System.IO.CoreFXFileSystemWatcherProxy.Operation (System.Action`4[T1,T2,T3,T4] map_op, System.Action`2[T1,T2] object_op, System.Object handle, System.Action`2[T1,T2] cancel_op) [0x00184] in &lt;e35dfeba7ed248b1a1d7afe3381392f9&gt;:0 解决方案: 123$ vi /etc/sysctl.conf$ 在文件末尾新添加一句：fs.inotify.max_user_instances=1024$ ./sbin/sysctl -p #使编辑内容生效]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo静态博客框架搭建]]></title>
    <url>%2F2019%2F04%2F11%2FHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[记录本人Hexo博客搭建过程，作为开启Hexo博客的第一篇博文。记录本人Hexo博客搭建过程，作为开启Hexo博客的第一篇博文。 nodeJs与git依赖环境搭建1.访问nodeJs官网，下载对应的版本：https://nodejs.org/en/download/ 2.安装完成后，配置环境变量，定位到nodeJs安装根目录 3.验证是否安装成功,成功出现nodeJs版本号，安装成功 1$ node -v 4.访问git官网，下载最新的git安装版本：https://www.git-scm.com/download/ 5.安装完毕后，查看版本号 ,出现版本号为安装成功 1$ git --version Hexo框架搭建与配置注意：以下步骤必须完成以上nodeJs和git环境安装后，才可进行 1.使用npm命令安装hexo 1$ npm install -g hexo-cli 2.使用命令验证版本 1$ hexo --version 3.安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 安装完之后，生成以下文件结构： 4.cd 进入hexo新建目录，启动Hexo 123$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. Hexo NexT主题下载与配置1.通过github下载主题 为建站根目录 12$ cd &lt;folder&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.下载完成后，修改主题配置文件（\themes\next_config.yaml） 12345# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 1234$ hexo clean$ hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 3.修改主题默认语言，编辑hexo根目录下的_config.yaml文件,zh-Hans为中文 1language: zh-Hans Hexo部署到github1.新建仓库,创建名称为：username.github.io (username为你的账号名称) 2.本地生成SSH 123$ git config --global user.name "username"$ git config --global user.email "youremail"$ ssh-keygen -t rsa -C "youremail" #一路回车 3.复制SSH 1$ pbcopy &lt; ~/.ssh/id_rsa.pub 4.添加ssh到github 5.在gitbash中，查看是否成功 1$ ssh -T git@github.com 6.先安装deploy-git 部署的命令,这样你才能用命令部署到GitHub 1$ npm install hexo-deployer-git --save 7.修改Hexo配置_config.yaml，修改为新建的仓库ssh地址 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 8.部署到github 123$ hexo clean$ hexo generate$ hexo deploy 9.访问 feirty.github.io 即可看到网站 github.io绑定域名 访问1.添加域名解析 2.获取github的ip 3.博客文件source中创建一个名为CNAME文件,添加域名，无需前缀 1mxo.mobi 4.重新部署 123$ hexo clean$ hexo generate$ hexo deploy 5.最后尝试用域名访问成功]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
